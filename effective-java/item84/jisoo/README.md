# [Item84] 프로그램의 동작을 스레드 스케줄러에 시대지 말라 
## 스레드 스케줄러 
- 여러 스레드가 실행 중일시, 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 결정. 
- 운영체제는 이 작업을 공정 하게 수행한다. 
- 구체적인 스케줄링 정책은 운영체제마다 다를 수 있다. 
- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 프랫폼에 이식하기 어렵기 때문에 프로그램이 운영체제의 스케줄링 정책에 좌지주지 되어서는 안됨. 
## 스레드 스케줄러에 의존 되지 않는 방법
- 스레드의 평군적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것. 
- 실행 준비가 된 스레드들은 많은 작업을 완료할때까지 계속 실행하도록 만들자. 
## 실행 가능한 스레드를 적게 유지하는 기법
- 스레드가 작업을 완료한 후에는 다음 일거리가 생길 떄까지 대기하도록 하는 것
- 즉, 스레드는 당장 처리해야 할 작업이 없다면 실행 돼서는 안 된다. 
- 스레드 풀 크기를 적절히 설정하고 작업은 짧게 유지하면 된다. 단 너무 짤으면 성능이 떨어진다.
### 바쁜대기 쓰지말자
- 스레드는 절대 바쁜 대기 상태가 되면 안된다. 공유 객체의 상태가 바뀔 떄까지 쉬지 않고 검사해서는 안된 다는 뜻.
```java
public class SlowCountDownLatch{
	private int count;
	
	public SlowCountDownLatch(int count){
		if ( count < 0 )
			throw new IllegarArgumentException(count+" <0");
		this.count = count;
	}
	
	public void await(){
		while(true){  // 바쁜대기 
			synchronized(this){
				if (count == 0){
					return;
				}
			}
		}
	}
	public synchronized void countDown(){
		if(count!=0){
			count--;
		}
	}
}
```
- 바쁜 대기는 스레드 스케줄러의 변덕에 취약 할 뿐 아니라, 프로세서에 큰 부담을 주어 다른 작업이 실행될 기회를 박탈한다. 
- 래치를 기다리는 스레드를 1000개 만들어 CoundownLatch와 비교해보니 약 10 배가 느렸다. 
### Thread.yield 쓰지말자
- 특정 스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해서 간신히 도아가는 프로그램을 보더라도,  Thread.yield를 써서 문제를 고쳐보려는 유혹을 떨쳐내자. 
- 증상은 호전 되더라도, 이식성은 그렇지 않을 것이다. 
- Thread.yield는 테스트 수단도 없다 차라리 애플리케이션 구조르 바꿔 동시에 실행 가능한 스레드 수가 적어지도록 조치해주자. 
### 스레드 우선순위 조절 하지말자
- 스레드 우선순위는 자바에서 이식성이 가장 나쁜 특성에 속한다. 
- 심각한 응답 불가 문제르 ㄹ스레드 우선순위로 해결하려는 시도는 절대 합리적이지 않다. 